// ===================================================================
// ESP32 RC CAR - SIMPLIFIED DISTANCE CONTROL SYSTEM
// Version: 5.0 - Minimum Distance Only with Indonesian Logs
// ===================================================================

// --- BAGIAN 1: INCLUDE LIBRARY ---
#include "esp_camera.h"
#include <WiFiMulti.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <EEPROM.h>
#include <ArduinoJson.h>
#include "time.h"

// --- BAGIAN 2: KONFIGURASI UTAMA ---

// --- Konfigurasi WiFi ---
WiFiMulti wifiMulti;
struct WiFiCredentials { const char* ssid; const char* password; };
WiFiCredentials wifiList[] = {
    {"YouTube_Studio_5G", "B3rkahS3lalu"},
    {"YouTube_Studio", "S3laluB3rkah"},
    {"Galaxy", "12345678"}
};

// --- Konfigurasi Pin ---
#define MOTOR_EN 2 
#define IN1 14
#define IN2 15
#define IN3 12
#define IN4 13
#define FLASH_PIN 4 
#define TRIG_PIN 0
#define ECHO_PIN 3

// --- Konfigurasi PWM ---
const int PWM_FREQ = 1000;
const int PWM_RESOLUTION = 8;
const int PWM_MOTOR_CHANNEL = 0;
const int PWM_FLASH_CHANNEL = 1;

// --- Konfigurasi MQTT ---
const char* mqtt_server = "098567b786d74be2863e6859abdf1f0e.s1.eu.hivemq.cloud";
const int mqtt_port = 8883;
const char* mqtt_user = "esp32-user"; 
const char* mqtt_password = "Jangan999";

// --- Definisi Topic MQTT ---
#define MQTT_CAM_STREAM_TOPIC "esp32/cam/stream"
#define MQTT_CONTROL_MOVE_TOPIC "esp32/car/control/move"
#define MQTT_CONTROL_SPEED_TOPIC "esp32/car/control/speed"
#define MQTT_CONTROL_FLASH_TOPIC "esp32/car/control/flash"
#define MQTT_DISTANCE_SETTINGS_TOPIC "esp32/car/config/distance"
#define MQTT_STATUS_TOPIC "esp32/car/status"
#define MQTT_LOG_TOPIC "esp32/car/log"
#define MQTT_COMMAND_AUTONOMOUS_TOPIC "esp32/car/command/autonomous"
#define MQTT_SENSOR_DISTANCE_TOPIC "esp32/car/sensor/distance"
#define MQTT_OBSTACLE_TOPIC "esp32/car/obstacle"

// --- Konfigurasi NTP (Waktu) ---
const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 7 * 3600;
const int   daylightOffset_sec = 0;

// --- Konfigurasi Pin Kamera (Model AI Thinker) ---
#define PWDN_GPIO_NUM 32
#define RESET_GPIO_NUM -1
#define XCLK_GPIO_NUM 0
#define SIOD_GPIO_NUM 26
#define SIOC_GPIO_NUM 27
#define Y9_GPIO_NUM 35
#define Y8_GPIO_NUM 34
#define Y7_GPIO_NUM 39
#define Y6_GPIO_NUM 36
#define Y5_GPIO_NUM 21
#define Y4_GPIO_NUM 19
#define Y3_GPIO_NUM 18
#define Y2_GPIO_NUM 5
#define VSYNC_GPIO_NUM 25
#define HREF_GPIO_NUM 23
#define PCLK_GPIO_NUM 22

// --- BAGIAN 3: EEPROM CONFIGURATION & DISTANCE SETTINGS ---

// EEPROM Memory Layout
#define EEPROM_SIZE 512
#define EEPROM_MAGIC_NUMBER 0xABCD
#define EEPROM_VERSION 1

// EEPROM Addresses
#define ADDR_MAGIC 0          // 2 bytes - Magic number for validation
#define ADDR_VERSION 2        // 1 byte - Settings version
#define ADDR_MIN_DISTANCE 3   // 2 bytes - Minimum distance (cm)
#define ADDR_CHECKSUM 5       // 1 byte - Simple checksum

// Distance Settings Structure - SIMPLIFIED
struct DistanceSettings {
    uint16_t minDistance;   // Minimum distance in cm (5-300)
};

// Default distance settings (in centimeters)
DistanceSettings defaultSettings = {
    .minDistance = 15,   // 15cm - minimum distance for stop/reverse
};

// Current active settings
DistanceSettings currentSettings;

// --- BAGIAN 4: INISIALISASI OBJEK & VARIABEL GLOBAL ---
WiFiClientSecure espClient;
PubSubClient client(espClient);

volatile int speed = 200;
unsigned long lastFrameTime = 0;
const long frameInterval = 50;
unsigned long lastStatusTime = 0;
const long statusInterval = 10000;
unsigned long lastDistanceTime = 0;
const long distanceInterval = 200;

bool isMqttConnectedBefore = false;
bool autonomousMode = false;
bool timeConfigured = false;
long currentDistance = 0;
long previousDistance = 0;

// --- VARIABEL ENHANCED UNTUK MODE AUTONOMOUS ---
enum AutonomousState {
    AUTO_FORWARD,
    AUTO_OBSTACLE_DETECTED,
    AUTO_STOPPING,
    AUTO_BACKING,
    AUTO_TURNING_LEFT,
    AUTO_CHECKING_LEFT,
    AUTO_TURNING_RIGHT,
    AUTO_CHECKING_RIGHT,
    AUTO_FINDING_PATH,
    AUTO_RESUME_FORWARD
};

AutonomousState autoState = AUTO_FORWARD;
unsigned long autoStateStartTime = 0;
unsigned long lastAutonomousLog = 0;
unsigned long lastObstacleLog = 0;
bool obstacleDetected = false;
int turnAttempts = 0;
const int maxTurnAttempts = 3;

// --- OPTIMASI CAMERA STREAMING ---
unsigned long lastCameraCleanup = 0;
const long cameraCleanupInterval = 5000;
int consecutiveFrameFailures = 0;
const int maxFrameFailures = 5;

// --- BAGIAN 5: EEPROM FUNCTIONS ---

/**
 * Calculate simple checksum for settings validation
 */
uint8_t calculateChecksum(const DistanceSettings& settings) {
    uint8_t checksum = 0;
    checksum ^= (settings.minDistance & 0xFF);
    checksum ^= (settings.minDistance >> 8);
    return checksum;
}

/**
 * Validate distance settings for safety and logic
 */
bool validateDistanceSettings(const DistanceSettings& settings) {
    // Range validation (5cm - 300cm)
    if (settings.minDistance < 5 || settings.minDistance > 300) return false;
    
    return true;
}

/**
 * Auto-correct invalid settings to safe values
 */
DistanceSettings autoCorrectSettings(DistanceSettings settings) {
    // Clamp to valid ranges
    settings.minDistance = constrain(settings.minDistance, 5, 300);
    
    return settings;
}

/**
 * Save distance settings to EEPROM with validation
 */
bool saveDistanceSettings(const DistanceSettings& settings) {
    // Validate settings before saving
    DistanceSettings validatedSettings = autoCorrectSettings(settings);
    
    if (!validateDistanceSettings(validatedSettings)) {
        logActivity("Validasi pengaturan gagal, menggunakan default");
        validatedSettings = defaultSettings;
    }
    
    // Write magic number and version
    EEPROM.writeUShort(ADDR_MAGIC, EEPROM_MAGIC_NUMBER);
    EEPROM.writeByte(ADDR_VERSION, EEPROM_VERSION);
    
    // Write settings
    EEPROM.writeUShort(ADDR_MIN_DISTANCE, validatedSettings.minDistance);
    
    // Write checksum
    uint8_t checksum = calculateChecksum(validatedSettings);
    EEPROM.writeByte(ADDR_CHECKSUM, checksum);
    
    // Commit to flash
    bool success = EEPROM.commit();
    
    if (success) {
        currentSettings = validatedSettings;
        logActivity("Pengaturan jarak disimpan ke EEPROM");
        logActivity("Jarak minimum: " + String(currentSettings.minDistance) + "cm");
    } else {
        logActivity("Gagal menyimpan pengaturan ke EEPROM");
    }
    
    return success;
}

/**
 * Load distance settings from EEPROM with validation
 */
bool loadDistanceSettings() {
    // Check magic number
    uint16_t magic = EEPROM.readUShort(ADDR_MAGIC);
    if (magic != EEPROM_MAGIC_NUMBER) {
        logActivity("EEPROM belum diinisialisasi, menggunakan default");
        return false;
    }
    
    // Check version
    uint8_t version = EEPROM.readByte(ADDR_VERSION);
    if (version != EEPROM_VERSION) {
        logActivity("Versi EEPROM tidak cocok, menggunakan default");
        return false;
    }
    
    // Read settings
    DistanceSettings loadedSettings;
    loadedSettings.minDistance = EEPROM.readUShort(ADDR_MIN_DISTANCE);
    
    // Verify checksum
    uint8_t storedChecksum = EEPROM.readByte(ADDR_CHECKSUM);
    uint8_t calculatedChecksum = calculateChecksum(loadedSettings);
    
    if (storedChecksum != calculatedChecksum) {
        logActivity("Checksum EEPROM tidak cocok, data rusak");
        return false;
    }
    
    // Validate loaded settings
    if (!validateDistanceSettings(loadedSettings)) {
        logActivity("Pengaturan yang dimuat tidak valid, menggunakan default");
        return false;
    }
    
    // Settings are valid, apply them
    currentSettings = loadedSettings;
    logActivity("Pengaturan jarak dimuat dari EEPROM");
    logActivity("Jarak minimum: " + String(currentSettings.minDistance) + "cm");
    
    return true;
}

/**
 * Initialize EEPROM and load settings
 */
void initializeEEPROM() {
    logActivity("Menginisialisasi EEPROM...");
    
    if (!EEPROM.begin(EEPROM_SIZE)) {
        logActivity("Inisialisasi EEPROM gagal!");
        currentSettings = defaultSettings;
        return;
    }
    
    // Try to load settings from EEPROM
    if (!loadDistanceSettings()) {
        // Failed to load, save defaults
        logActivity("Menyimpan pengaturan default ke EEPROM...");
        currentSettings = defaultSettings;
        saveDistanceSettings(currentSettings);
    }
    
    logActivity("EEPROM berhasil diinisialisasi");
}

// --- BAGIAN 6: FUNGSI-FUNGSI UTAMA ---

void ensureSerialReady() {
    if (!Serial) {
        Serial.begin(115200);
        delay(500);
    }
    while (Serial.available()) {
        Serial.read();
    }
}

void logActivity(const String& message) {
    ensureSerialReady();
    
    unsigned long uptime = millis() / 1000;
    String timestamp = "[" + String(uptime) + "s] ";
    String logMessage = timestamp + message;
    
    Serial.println(logMessage);
    Serial.flush();
    
    if (client.connected() && client.state() == MQTT_CONNECTED) {
        client.publish(MQTT_LOG_TOPIC, message.c_str(), false);
    }
}

void logObstacle(long distance, const String& action) {
    String obstacleMessage = "HALANGAN TERDETEKSI! Jarak: " + String(distance) + "cm (Batas: " + 
                            String(currentSettings.minDistance) + "cm) - Aksi: " + action;
    logActivity(obstacleMessage);
    
    if (client.connected()) {
        char obstacleJson[300];
        snprintf(obstacleJson, sizeof(obstacleJson),
            "{\"distance\":%ld,\"threshold\":%d,\"action\":\"%s\",\"timestamp\":%lu}",
            distance, currentSettings.minDistance, action.c_str(), millis()
        );
        client.publish(MQTT_OBSTACLE_TOPIC, obstacleJson, false);
    }
}

void setupTime() {
    logActivity("Memulai sinkronisasi waktu...");
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    logActivity("NTP dikonfigurasi - sinkronisasi background");
    timeConfigured = true;
}

// --- MOTOR FUNCTIONS (OPTIMIZED) ---
void moveForward() { 
    ledcWrite(PWM_MOTOR_CHANNEL, speed); 
    digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); 
    digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW); 
}

void moveBackward() { 
    ledcWrite(PWM_MOTOR_CHANNEL, speed); 
    digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH); 
    digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH); 
}

void turnLeft() { 
    ledcWrite(PWM_MOTOR_CHANNEL, speed); 
    digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); 
    digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH); 
}

void turnRight() { 
    ledcWrite(PWM_MOTOR_CHANNEL, speed); 
    digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH); 
    digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW); 
}

void stopMotors() { 
    ledcWrite(PWM_MOTOR_CHANNEL, 0); 
    digitalWrite(IN1, LOW); digitalWrite(IN2, LOW); 
    digitalWrite(IN3, LOW); digitalWrite(IN4, LOW); 
}

void handleCommand(String cmd) {
    logActivity("Perintah: " + cmd);
    if (cmd == "forward") moveForward();
    else if (cmd == "backward") moveBackward();
    else if (cmd == "left") turnLeft();
    else if (cmd == "right") turnRight();
    else if (cmd == "stop") stopMotors();
}

void setupCamera() {
    logActivity("Memulai inisialisasi kamera...");
    
    camera_config_t config;
    config.ledc_channel = LEDC_CHANNEL_2;
    config.ledc_timer = LEDC_TIMER_1;
    
    config.pin_d0 = Y2_GPIO_NUM; config.pin_d1 = Y3_GPIO_NUM; config.pin_d2 = Y4_GPIO_NUM;
    config.pin_d3 = Y5_GPIO_NUM; config.pin_d4 = Y6_GPIO_NUM; config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM; config.pin_d7 = Y9_GPIO_NUM; config.pin_xclk = XCLK_GPIO_NUM;
    config.pin_pclk = PCLK_GPIO_NUM; config.pin_vsync = VSYNC_GPIO_NUM; config.pin_href = HREF_GPIO_NUM;
    config.pin_sscb_sda = SIOD_GPIO_NUM; config.pin_sscb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = PWDN_GPIO_NUM; config.pin_reset = RESET_GPIO_NUM;
    config.xclk_freq_hz = 20000000;
    config.pixel_format = PIXFORMAT_JPEG;

    config.frame_size = FRAMESIZE_QVGA;
    config.jpeg_quality = 15;
    config.fb_count = 2;
    
    logActivity("Konfigurasi kamera selesai, menginisialisasi...");
    esp_err_t err = esp_camera_init(&config);
    if (err != ESP_OK) {
        logActivity("Inisialisasi kamera gagal dengan error: " + String(err));
        logActivity("Memulai ulang sistem...");
        delay(3000);
        ESP.restart();
    }
    
    sensor_t *s = esp_camera_sensor_get();
    if (s) {
        logActivity("Mengoptimalkan pengaturan sensor kamera...");
        s->set_brightness(s, 1);
        s->set_contrast(s, 1);
        s->set_saturation(s, 0);
        s->set_special_effect(s, 0);
        s->set_whitebal(s, 1);
        s->set_awb_gain(s, 1);
        s->set_wb_mode(s, 0);
        s->set_exposure_ctrl(s, 1);
        s->set_aec2(s, 0);
        s->set_ae_level(s, 0);
        s->set_aec_value(s, 300);
        s->set_gain_ctrl(s, 1);
        s->set_agc_gain(s, 0);
        s->set_gainceiling(s, (gainceiling_t)0);
        s->set_bpc(s, 0);
        s->set_wpc(s, 1);
        s->set_raw_gma(s, 1);
        s->set_lenc(s, 1);
        s->set_hmirror(s, 0);
        s->set_vflip(s, 0);
        s->set_dcw(s, 1);
        s->set_colorbar(s, 0);
        logActivity("Sensor kamera dioptimalkan");
    }
    
    logActivity("Kamera siap!");
}

void publishStatus() {
    char jsonPayload[400];
    snprintf(jsonPayload, sizeof(jsonPayload),
        "{\"uptime\":%lu,\"rssi\":%d,\"heap\":%u,\"auto\":%s,\"dist\":%ld,\"state\":%d,\"obstacle\":%s,\"attempts\":%d,\"settings\":{\"min\":%d}}",
        millis()/1000, WiFi.RSSI(), ESP.getFreeHeap(), 
        autonomousMode ? "true" : "false", currentDistance, autoState,
        obstacleDetected ? "true" : "false", turnAttempts,
        currentSettings.minDistance
    );
    
    client.publish(MQTT_STATUS_TOPIC, jsonPayload, false);
}

// OPTIMIZED DISTANCE READING
long getDistance() {
    digitalWrite(TRIG_PIN, LOW);
    delayMicroseconds(2);
    digitalWrite(TRIG_PIN, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG_PIN, LOW);
    
    long duration = pulseIn(ECHO_PIN, HIGH, 20000);
    if (duration == 0) return 999;
    
    long distance = duration / 2 / 29.1;
    return (distance > 0 && distance < 300) ? distance : 999;
}

// ENHANCED AUTONOMOUS MODE WITH ADJUSTABLE DISTANCE SETTINGS
void runAutonomousLogic() {
    unsigned long currentTime = millis();
    
    // Use current settings for obstacle detection
    int obstacleThreshold = currentSettings.minDistance;
    int criticalDistance = max(5, obstacleThreshold - 5);
    
    // Check for obstacles using current settings
    if (currentDistance <= obstacleThreshold && currentDistance > 0) {
        if (!obstacleDetected) {
            obstacleDetected = true;
            logObstacle(currentDistance, "Deteksi Pertama");
        }
        
        if (currentTime - lastObstacleLog > 2000) {
            logObstacle(currentDistance, "Deteksi Berkelanjutan");
            lastObstacleLog = currentTime;
        }
    } else if (currentDistance > obstacleThreshold) {
        if (obstacleDetected) {
            obstacleDetected = false;
            logActivity("Jalur bebas - Jarak: " + String(currentDistance) + "cm (Batas: " + String(obstacleThreshold) + "cm)");
        }
    }
    
    if (currentTime - lastAutonomousLog > 3000) {
        logActivity("MODE AUTO - Jarak: " + String(currentDistance) + "cm - Batas: " + String(obstacleThreshold) + "cm - Status: " + getStateString(autoState));
        lastAutonomousLog = currentTime;
    }
    
    switch (autoState) {
        case AUTO_FORWARD:
            if (currentDistance >= obstacleThreshold || currentDistance == 999) {
                moveForward();
            } else {
                logObstacle(currentDistance, "Menghentikan Gerakan Maju");
                autoState = AUTO_OBSTACLE_DETECTED;
                autoStateStartTime = currentTime;
            }
            break;
            
        case AUTO_OBSTACLE_DETECTED:
            stopMotors();
            logObstacle(currentDistance, "Halangan Dikonfirmasi - Memulai Penghindaran");
            autoState = AUTO_STOPPING;
            autoStateStartTime = currentTime;
            break;
            
        case AUTO_STOPPING:
            stopMotors();
            if (currentTime - autoStateStartTime >= 200) {
                if (currentDistance <= criticalDistance) {
                    logObstacle(currentDistance, "Jarak Kritis - Mundur");
                    autoState = AUTO_BACKING;
                } else {
                    logObstacle(currentDistance, "Mencari Jalur Alternatif");
                    autoState = AUTO_FINDING_PATH;
                }
                autoStateStartTime = currentTime;
                turnAttempts = 0;
            }
            break;
            
        case AUTO_BACKING:
            moveBackward();
            if (currentTime - autoStateStartTime >= 600) {
                logActivity("Mundur selesai - Memulai pencarian jalur");
                autoState = AUTO_FINDING_PATH;
                autoStateStartTime = currentTime;
                turnAttempts = 0;
            }
            break;
            
        case AUTO_FINDING_PATH:
            stopMotors();
            if (currentTime - autoStateStartTime >= 100) {
                logActivity("Mencoba mencari jalur alternatif - Percobaan: " + String(turnAttempts + 1));
                autoState = AUTO_TURNING_LEFT;
                autoStateStartTime = currentTime;
            }
            break;
            
        case AUTO_TURNING_LEFT:
            turnLeft();
            if (currentTime - autoStateStartTime >= 800) {
                logActivity("Belok kiri selesai - Memeriksa jalur");
                autoState = AUTO_CHECKING_LEFT;
                autoStateStartTime = currentTime;
            }
            break;
            
        case AUTO_CHECKING_LEFT:
            stopMotors();
            if (currentTime - autoStateStartTime >= 300) {
                if (currentDistance >= obstacleThreshold || currentDistance == 999) {
                    logActivity("Jalur kiri bebas - Melanjutkan maju");
                    autoState = AUTO_RESUME_FORWARD;
                    turnAttempts = 0;
                } else {
                    logActivity("Jalur kiri terblokir - Mencoba kanan");
                    autoState = AUTO_TURNING_RIGHT;
                    autoStateStartTime = currentTime;
                }
            }
            break;
            
        case AUTO_TURNING_RIGHT:
            turnRight();
            if (currentTime - autoStateStartTime >= 1600) {
                logActivity("Belok kanan selesai - Memeriksa jalur");
                autoState = AUTO_CHECKING_RIGHT;
                autoStateStartTime = currentTime;
            }
            break;
            
        case AUTO_CHECKING_RIGHT:
            stopMotors();
            if (currentTime - autoStateStartTime >= 300) {
                if (currentDistance >= obstacleThreshold || currentDistance == 999) {
                    logActivity("Jalur kanan bebas - Melanjutkan maju");
                    autoState = AUTO_RESUME_FORWARD;
                    turnAttempts = 0;
                } else {
                    turnAttempts++;
                    if (turnAttempts < maxTurnAttempts) {
                        logActivity("Jalur kanan terblokir - Mundur dan coba lagi");
                        autoState = AUTO_BACKING;
                        autoStateStartTime = currentTime;
                    } else {
                        logActivity("Maksimum percobaan tercapai - Menunggu jalur bebas");
                        autoState = AUTO_STOPPING;
                        autoStateStartTime = currentTime;
                        turnAttempts = 0;
                    }
                }
            }
            break;
            
        case AUTO_RESUME_FORWARD:
            if (currentDistance >= obstacleThreshold || currentDistance == 999) {
                logActivity("Melanjutkan gerakan maju");
                autoState = AUTO_FORWARD;
                moveForward();
            } else {
                logActivity("Jalur terblokir lagi - Memulai ulang penghindaran");
                autoState = AUTO_OBSTACLE_DETECTED;
                autoStateStartTime = currentTime;
            }
            break;
    }
}

String getStateString(AutonomousState state) {
    switch (state) {
        case AUTO_FORWARD: return "MAJU";
        case AUTO_OBSTACLE_DETECTED: return "HALANGAN_TERDETEKSI";
        case AUTO_STOPPING: return "BERHENTI";
        case AUTO_BACKING: return "MUNDUR";
        case AUTO_TURNING_LEFT: return "BELOK_KIRI";
        case AUTO_CHECKING_LEFT: return "CEK_KIRI";
        case AUTO_TURNING_RIGHT: return "BELOK_KANAN";
        case AUTO_CHECKING_RIGHT: return "CEK_KANAN";
        case AUTO_FINDING_PATH: return "CARI_JALUR";
        case AUTO_RESUME_FORWARD: return "LANJUT_MAJU";
        default: return "TIDAK_DIKENAL";
    }
}

void signalOnline() {
    for (int i = 0; i < 2; i++) {
        ledcWrite(PWM_FLASH_CHANNEL, 100);
        delay(100);
        ledcWrite(PWM_FLASH_CHANNEL, 0);
        delay(100);
    }
}

void callback(char* topic, byte* payload, unsigned int length) {
    String message;
    for (int i = 0; i < length; i++) { 
        message += (char)payload[i]; 
    }
    String topicStr = String(topic);
    
    // Handle distance settings configuration
    if (topicStr == MQTT_DISTANCE_SETTINGS_TOPIC) {
        logActivity("Menerima pengaturan jarak: " + message);
        
        // Parse JSON payload
        DynamicJsonDocument doc(512);
        DeserializationError error = deserializeJson(doc, message);
        
        if (error) {
            logActivity("Parsing JSON gagal: " + String(error.c_str()));
            return;
        }
        
        // Extract settings from JSON
        DistanceSettings newSettings;
        newSettings.minDistance = doc["minDistance"] | currentSettings.minDistance;
        
        // Validate and save new settings
        if (validateDistanceSettings(newSettings)) {
            if (saveDistanceSettings(newSettings)) {
                logActivity("Pengaturan jarak diperbarui dan disimpan");
                logActivity("Pengaturan baru - Minimum: " + String(currentSettings.minDistance) + "cm");
                
                // Send confirmation back to web interface
                char confirmJson[200];
                snprintf(confirmJson, sizeof(confirmJson),
                    "{\"status\":\"success\",\"min\":%d,\"timestamp\":%lu}",
                    currentSettings.minDistance, millis()
                );
                client.publish(MQTT_STATUS_TOPIC, confirmJson, false);
            } else {
                logActivity("Gagal menyimpan pengaturan jarak");
            }
        } else {
            logActivity("Pengaturan jarak yang diterima tidak valid");
        }
        return;
    }
    
    if (topicStr == MQTT_COMMAND_AUTONOMOUS_TOPIC) {
        if (message == "on") {
            logActivity("MODE AUTONOMOUS DIAKTIFKAN");
            logActivity("Menggunakan pengaturan jarak - Minimum: " + String(currentSettings.minDistance) + "cm");
            autonomousMode = true;
            autoState = AUTO_FORWARD;
            autoStateStartTime = millis();
            obstacleDetected = false;
            turnAttempts = 0;
        } else if (message == "off") {
            logActivity("MODE AUTONOMOUS DINONAKTIFKAN");
            autonomousMode = false;
            stopMotors();
            autoState = AUTO_FORWARD;
            obstacleDetected = false;
            turnAttempts = 0;
        }
        return;
    }

    if (!autonomousMode) {
        if (topicStr == MQTT_CONTROL_MOVE_TOPIC) { 
            handleCommand(message); 
        } 
        else if (topicStr == MQTT_CONTROL_SPEED_TOPIC) {
            speed = constrain(message.toInt(), 50, 255);
            if (ledcRead(PWM_MOTOR_CHANNEL) > 0) { 
                ledcWrite(PWM_MOTOR_CHANNEL, speed); 
            }
        } 
        else if (topicStr == MQTT_CONTROL_FLASH_TOPIC) {
            int flashValue = constrain(message.toInt(), 0, 255);
            ledcWrite(PWM_FLASH_CHANNEL, flashValue);
        }
    }
}

void reconnect() {
    static unsigned long lastReconnectAttempt = 0;
    
    if (millis() - lastReconnectAttempt < 3000) return;
    lastReconnectAttempt = millis();
    
    logActivity("Menghubungkan ke broker MQTT...");
    
    String clientId = "ESP32-Car-" + String(random(0xffff), HEX);
    if (client.connect(clientId.c_str(), mqtt_user, mqtt_password)) {
        logActivity("MQTT Terhubung!");
        logActivity("Client ID: " + clientId);
        isMqttConnectedBefore = true;
        
        logActivity("Berlangganan ke topik...");
        client.subscribe(MQTT_CONTROL_MOVE_TOPIC);
        client.subscribe(MQTT_CONTROL_SPEED_TOPIC);
        client.subscribe(MQTT_CONTROL_FLASH_TOPIC);
        client.subscribe(MQTT_COMMAND_AUTONOMOUS_TOPIC);
        client.subscribe(MQTT_DISTANCE_SETTINGS_TOPIC);
        logActivity("Berlangganan ke semua topik");
        
        // Send current settings to web interface
        char settingsJson[200];
        snprintf(settingsJson, sizeof(settingsJson),
            "{\"type\":\"settings\",\"min\":%d,\"timestamp\":%lu}",
            currentSettings.minDistance, millis()
        );
        client.publish(MQTT_STATUS_TOPIC, settingsJson, false);
        
        signalOnline();
    } else {
        logActivity("Koneksi MQTT gagal dengan kode: " + String(client.state()));
    }
}

// --- BAGIAN 7: SETUP ---
void setup() {
    Serial.begin(115200);
    delay(2000);
    
    while (Serial.available()) {
        Serial.read();
    }
    
    Serial.println();
    Serial.println("=====================================");
    Serial.println("  ESP32 RC Car v5.0 - Sederhana     ");
    Serial.println("   Kontrol Jarak Minimum Saja       ");
    Serial.println("=====================================");
    Serial.println();
    
    logActivity("Sistem booting...");
    logActivity("Free Heap: " + String(ESP.getFreeHeap()) + " bytes");
    
    // Initialize EEPROM and load distance settings
    initializeEEPROM();
    
    // PWM Setup
    logActivity("Menginisialisasi PWM...");
    ledcSetup(PWM_MOTOR_CHANNEL, PWM_FREQ, PWM_RESOLUTION);
    ledcAttachPin(MOTOR_EN, PWM_MOTOR_CHANNEL);
    ledcSetup(PWM_FLASH_CHANNEL, PWM_FREQ, PWM_RESOLUTION);
    ledcAttachPin(FLASH_PIN, PWM_FLASH_CHANNEL);
    logActivity("PWM diinisialisasi");
    
    // GPIO Setup
    logActivity("Mengatur pin GPIO...");
    pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);
    pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);
    pinMode(TRIG_PIN, OUTPUT); pinMode(ECHO_PIN, INPUT);
    
    digitalWrite(IN1, LOW); digitalWrite(IN2, LOW);
    digitalWrite(IN3, LOW); digitalWrite(IN4, LOW);
    ledcWrite(PWM_MOTOR_CHANNEL, 0);
    ledcWrite(PWM_FLASH_CHANNEL, 0);
    logActivity("Pin GPIO dikonfigurasi");
    
    // Camera Setup
    logActivity("Menginisialisasi kamera...");
    setupCamera();
    
    // WiFi Setup
    logActivity("Menghubungkan ke WiFi...");
    for (auto const& cred : wifiList) { 
        wifiMulti.addAP(cred.ssid, cred.password); 
        logActivity("WiFi ditambahkan: " + String(cred.ssid));
    }
    
    if(wifiMulti.run(15000) == WL_CONNECTED) {
        logActivity("WiFi Terhubung!");
        logActivity("SSID: " + WiFi.SSID());
        logActivity("Alamat IP: " + WiFi.localIP().toString());
        logActivity("Sinyal: " + String(WiFi.RSSI()) + " dBm");
    } else {
        logActivity("Koneksi WiFi gagal!");
        logActivity("Memulai ulang dalam 5 detik...");
        delay(5000);
        ESP.restart();
    }
    
    // MQTT Setup
    logActivity("Mengkonfigurasi MQTT...");
    espClient.setInsecure();
    client.setBufferSize(24000);
    client.setServer(mqtt_server, mqtt_port);
    client.setCallback(callback);
    client.setKeepAlive(30);
    
    logActivity("Setup selesai!");
    logActivity("Pengaturan jarak aktif:");
    logActivity("- Jarak minimum: " + String(currentSettings.minDistance) + "cm");
    logActivity("Menunggu koneksi MQTT...");
    
    Serial.println("=====================================");
    Serial.println("         SISTEM SIAP");
    Serial.println("=====================================");
    Serial.println();
}

// --- BAGIAN 8: MAIN LOOP ---
void loop() {
    // WiFi check
    if (WiFi.status() != WL_CONNECTED) {
        if(wifiMulti.run(5000) != WL_CONNECTED) {
            ESP.restart();
        }
    }
    
    // MQTT connection
    if (!client.connected()) {
        reconnect();
    }
    client.loop();
    
    // Distance reading with current settings
    if (millis() - lastDistanceTime > distanceInterval) {
        previousDistance = currentDistance;
        currentDistance = getDistance();
        
        if (currentDistance < 400 && client.connected()) {
            char distStr[8];
            dtostrf(currentDistance, 3, 0, distStr);
            client.publish(MQTT_SENSOR_DISTANCE_TOPIC, distStr, false);
        }
        lastDistanceTime = millis();
    }
    
    // Autonomous mode with adjustable distance settings
    if (autonomousMode) {
        runAutonomousLogic();
    }
    
    // Camera streaming
    if (millis() - lastFrameTime > frameInterval) {
        if (client.connected()) {
            camera_fb_t* fb = esp_camera_fb_get();
            if (fb && fb->len > 0 && fb->len < 20000) {
                bool success = client.publish(MQTT_CAM_STREAM_TOPIC, fb->buf, fb->len, false);
                if (success) {
                    consecutiveFrameFailures = 0;
                } else {
                    consecutiveFrameFailures++;
                    if (consecutiveFrameFailures > maxFrameFailures) {
                        logActivity("Masalah streaming kamera, memulai ulang...");
                        ESP.restart();
                    }
                }
                esp_camera_fb_return(fb);
            } else {
                if (fb) esp_camera_fb_return(fb);
                consecutiveFrameFailures++;
            }
        }
        lastFrameTime = millis();
    }
    
    // Status update
    if (millis() - lastStatusTime > statusInterval) {
        if (client.connected()) {
            publishStatus();
        }
        lastStatusTime = millis();
    }
    
    delay(1);
}